#include <algorithm>

#include "safetyhook/Factory.hpp"
#include "safetyhook/InlineHook.hpp"

#include "safetyhook/MidHook.hpp"

namespace safetyhook {

#ifdef _M_X64
const uint8_t asm_data[] = {0x54, 0x55, 0x50, 0x53, 0x51, 0x52, 0x56, 0x57, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41,
    0x53, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x9C, 0x48, 0x8D, 0x0C, 0x24, 0x48, 0x83, 0xEC, 0x28, 0x48,
    0xF7, 0xC4, 0x08, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x10, 0x00, 0x00, 0x00, 0x48, 0x83, 0xEC, 0x08, 0x48, 0xC7, 0xC3,
    0x30, 0x00, 0x00, 0x00, 0xE9, 0x07, 0x00, 0x00, 0x00, 0x48, 0xC7, 0xC3, 0x28, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x22,
    0x00, 0x00, 0x00, 0x48, 0x01, 0xDC, 0x9D, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x41, 0x5B, 0x41, 0x5A,
    0x41, 0x59, 0x41, 0x58, 0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0x58, 0x5D, 0x5C, 0xFF, 0x25, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#else
const uint8_t asm_data[] = {0x54, 0x55, 0x50, 0x53, 0x51, 0x52, 0x56, 0x57, 0x9C, 0x54, 0xFF, 0x15, 0x00, 0x00, 0x00,
    0x00, 0x83, 0xC4, 0x04, 0x9D, 0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0x58, 0x5D, 0x5C, 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#endif

MidHook::MidHook(std::shared_ptr<Factory> factory, uintptr_t target, MidHookFn destination)
    : m_factory{std::move(factory)}, m_target{target}, m_destination{destination} {
    auto builder = Factory::acquire();
    m_stub = builder.allocate(sizeof(asm_data));

    std::copy_n(asm_data, sizeof(asm_data), (uint8_t*)m_stub);

#ifdef _M_X64
    *(MidHookFn*)(m_stub + sizeof(asm_data) - 16) = m_destination;
#else
    *(MidHookFn*)(m_stub + sizeof(asm_data) - 8) = m_destination;

    // 32-bit has some relocations we need to fix up as well.
    *(uintptr_t*)(m_stub + 0xA + 2) = m_stub + sizeof(asm_data) - 8;
    *(uintptr_t*)(m_stub + 0x1C + 2) = m_stub + sizeof(asm_data) - 4;
#endif

    m_hook = builder.create_inline((void*)m_target, (void*)m_stub);

    if (m_hook == nullptr) {
        builder.free(m_stub, sizeof(asm_data));
        m_stub = 0;
        return;
    }

#ifdef _M_X64
    *(uintptr_t*)(m_stub + sizeof(asm_data) - 8) = m_hook->trampoline();
#else
    *(uintptr_t*)(m_stub + sizeof(asm_data) - 4) = m_hook->trampoline();
#endif
}

MidHook::~MidHook() {
    if (m_stub != 0) {
        auto builder = Factory::acquire();
        builder.free(m_stub, sizeof(asm_data));
    }

    m_hook.reset();
}

} // namespace safetyhook